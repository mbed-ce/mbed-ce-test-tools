/*
 * Copyright (c) 2023 ARM Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "mbed.h"
#include "greentea-client/test_env.h"
#include "unity.h"
#include "utest.h"

#include "ci_test_common.h"

#include <random>

using namespace utest::v1;

AnalogIn adc(PIN_ANALOG_IN);
PwmOut pwmOut(PIN_GPOUT_1_PWM);

// How long to wait when setting a PWM value for the hardware filter to settle
constexpr std::chrono::milliseconds PWM_FILTER_DELAY = 50ms; // nominal time constant 10ms

// GPIO output voltage expressed as a percent of the ADC reference voltage.  Experimentally determined by the first test case.
float ioVoltageADCPercent;

std::mt19937 randomGen(287327); // Fixed random seed for repeatability

/*
 * Tests that we can see a response on the ADC when setting the PWM pin to a constant high or low value.
 */
void test_adc_digital_value()
{
    // The filter in hardware is set up for a PWM signal of ~10kHz.
    pwmOut.period(.0001);

    // Make sure turning the PWM off gets a zero percent input on the ADC
    pwmOut.write(0);
    ThisThread::sleep_for(PWM_FILTER_DELAY);
    float zeroADCPercent = adc.read();
    printf("With the PWM at full off, the ADC reads %.01f%% of reference voltage.\n", zeroADCPercent * 100.0f);
    TEST_ASSERT_FLOAT_WITHIN(.1f, 0, zeroADCPercent);

    // Now see what happens when we turn the PWM all the way on
    pwmOut.write(1);
    ThisThread::sleep_for(PWM_FILTER_DELAY);
    ioVoltageADCPercent = adc.read();
    printf("With the PWM at full on, the ADC reads %.01f%% of reference voltage.\n", ioVoltageADCPercent * 100.0f);

    // We don't actually know what the IO voltage is relative to the ADC reference voltage, but it's a fair bet
    // that it should be at least 10%, so make sure we got at least some kind of reading
    TEST_ASSERT(ioVoltageADCPercent > 0.1f);

    // If the target provides an ADC Vref value, check that as well.
    if(isnan(MBED_CONF_TARGET_DEFAULT_ADC_VREF))
    {
        printf("Cannot convert to volts, target.default-adc-vref is not set for this target");
    }
    else
    {
        float ioVoltageVolts = adc.read_voltage();
        printf("Based on target.default-adc-vref of %.02fV, the digital IO voltage of this target is %.02fV.",
               MBED_CONF_TARGET_DEFAULT_ADC_VREF, ioVoltageVolts);

        // In a sane world we expect the IO voltage to be between 1.8 and 5 volts so we can at least check that
        // to help spot bad target.default-adc-vref values
        TEST_ASSERT(ioVoltageVolts >= 1.7f);
        TEST_ASSERT(ioVoltageVolts <= 5.1f);
    }

}

/*
 * Test reading analog values with the ADC.
 * The analog values are generated by sending a PWM signal through a hardware filter.
 */
void test_adc_analog_value()
{
    // The filter in hardware is set up for a PWM signal of ~10kHz.
    pwmOut.period(.0001);

    const size_t numSteps = 10;

    // Allow a 1.5% tolerance on the read ADC values.  That should be about right because most Mbed targets
    // have between an 8 bit and a 12 bit ADC.
    // The least accurate ADC observed so far is on the RP2040, which was up to 1.1% off.
    const float adcTolerancePercent = .015f;

    for(size_t stepIdx = 0; stepIdx < numSteps; ++stepIdx)
    {
        // Write the analog value
        float dutyCyclePercent = stepIdx / static_cast<float>(numSteps);
        pwmOut.write(dutyCyclePercent);
        ThisThread::sleep_for(PWM_FILTER_DELAY);

        // Get and check the result
        float adcPercent = adc.read();
        float expectedADCPercent = dutyCyclePercent * ioVoltageADCPercent;
        printf("PWM duty cycle of %.01f%% produced an ADC reading of %.01f%% (expected %.01f%%)\n",
               dutyCyclePercent * 100.0f, adcPercent * 100.0f, expectedADCPercent * 100.0f);
        TEST_ASSERT_FLOAT_WITHIN(adcTolerancePercent, expectedADCPercent, adcPercent);
    }
}

/*
 * Test that we are actually hitting the PWM frequencies and duty cycles we are supposed to be.
 * This uses the Sigrok logic analyzer to detect the duty cycle and PWM frequency
 */
template<uint32_t period_us>
void test_pwm()
{
    pwmOut.period_us(period_us);
    const float frequency = 1e6 / period_us;

    const size_t numTrials = 5;

    for(size_t trial = 0; trial < numTrials; ++trial)
    {
        // Randomly choose a duty cycle for the trial.
        // With the logic analyzer running at 4 MHz, each pulse needs to last at least 250 ns for it to be detectable.
        // Example: if period_us is 1us, then the minimum duty cycle is (250ns / 1000ns) = 0.25
        float minPeriodPercent = 250 / (period_us * 1e3);

        float maxPeriodPercent = 1 - minPeriodPercent;

        float dutyCycle = std::uniform_real_distribution<float>(minPeriodPercent, maxPeriodPercent)(randomGen);

        pwmOut.write(dutyCycle);

        // Use the host test to measure the signal attributes
        greentea_send_kv("analyze_signal", "please");

        char receivedKey[64], receivedValue[64];
        float measuredFrequencyHz = 0;
        float measuredDutyCycle = 0;
        while (1) {
            greentea_parse_kv(receivedKey, receivedValue, sizeof(receivedKey), sizeof(receivedValue));

            if(strncmp("frequency", receivedKey, sizeof(receivedKey) - 1) == 0)
            {
                measuredFrequencyHz = atof(receivedValue);
            }
            if(strncmp("duty_cycle", receivedKey, sizeof(receivedKey) - 1) == 0)
            {
                measuredDutyCycle = atof(receivedValue);

                // We get the duty cycle second so we can break once we have it
                break;
            }
        }

        // For frequency, the host test measures for 100 ms, meaning that it should be able to
        // detect frequency within +-10Hz.  We'll double to 20Hz that to be a bit generous.
        // Note that we only run at even power-of-10 frequencies, so most MCUs *should* be able to hit them
        // precisely with a clock divider.  We shall see if any do not meet this assumption though..
        const float frequencyTolerance = 20;

        // For duty cycle, implementations should hopefully be at least 0.1% accurate.
        // However, at high clock frequencies, the resolution often gets worse, because the timer concerned might
        // only be counting to a few hundred before resetting.
        // Example: on RP2040, at 1MHz, the PWM counts to 125 before resetting, so we have an accuracy of 0.01 us
        // on a period of 1 us (giving a resolution a bit better than 1%)
        // We'll add another factor of 10 and say that we must only be as accurate as 0.1us if 0.1us is more
        // than 0.1% of the period, so for the RP2040 at 1MHz, the requirement would only be 10% duty cycle accuracy.
        const float dutyCycleTolerance = std::max(.001f, .1f / period_us);

        printf("Expected PWM frequency was %.00f Hz (+- %.00f Hz) and duty cycle was %.02f%% (+-%.02f%%), host measured frequency %.00f Hz and duty cycle %.02f%%\n",
               frequency,
               frequencyTolerance,
               dutyCycle * 100.0f,
               dutyCycleTolerance * 100.0f,
               measuredFrequencyHz,
               measuredDutyCycle * 100.0f);

        TEST_ASSERT_FLOAT_WITHIN(frequencyTolerance, frequency, measuredFrequencyHz);
        TEST_ASSERT_FLOAT_WITHIN(dutyCycleTolerance, dutyCycle, measuredDutyCycle);

        // Extra test: check that read_pulsewidth_us() produces the correct value
        float pulseWidthUs = dutyCycle * period_us;
        TEST_ASSERT_EQUAL_INT32(lroundf(pulseWidthUs), pwmOut.read_pulsewidth_us());
    }

    // As one last extra test, make sure that reading the period gets the correct value
    TEST_ASSERT_EQUAL_INT32(period_us, pwmOut.read_period_us());
}

utest::v1::status_t test_setup(const size_t number_of_cases) {
    // Setup Greentea using a reasonable timeout in seconds
    GREENTEA_SETUP(60, "signal_analyzer_test");

    return verbose_test_setup_handler(number_of_cases);
}

// Test cases
Case cases[] = {
    Case("Test reading digital values with the ADC", test_adc_digital_value),
    Case("Test reading analog values with the ADC", test_adc_analog_value),
    Case("Test PWM frequency and duty cycle (freq = 50 Hz)", test_pwm<20000>),
    Case("Test PWM frequency and duty cycle (freq = 1 kHz)", test_pwm<1000>),
    Case("Test PWM frequency and duty cycle (freq = 10 kHz)", test_pwm<100>),
    Case("Test PWM frequency and duty cycle (freq = 100 kHz)", test_pwm<10>),

    // Note: Many targets currently cannot do 1MHz PWM.  This test will help figure out which ones those are.
    Case("Test PWM frequency and duty cycle (freq = 1 MHz)", test_pwm<1>),
};

Specification specification(test_setup, cases, greentea_continue_handlers);

// Entry point into the tests
int main()
{
    return !Harness::run(specification);
}
